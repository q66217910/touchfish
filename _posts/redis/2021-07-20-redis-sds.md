---
layout: post
title: REDIS 数据类型之 SDS
category: redis
tags: [redis]
no-post-nav: true
---

REDIS 数据类型之 SDS
===

SDS分配一段连续的内存来存储动态字符串



### 1.SDS的数据结构

- **len:**  记录buf数组中已使用字节的数量 , 等于 SDS 保存字符串的长度.
- **alloc:** 分配的字符数量(可用长度)
- **flags:** 类型标志位
- **buf[]:** 存储的字符串内容

```c
typedef char *sds;

//SDS的类型
define SDS_TYPE_5  0
define SDS_TYPE_8  1
define SDS_TYPE_16 2
define SDS_TYPE_32 3
define SDS_TYPE_64 4

//适配不同长度
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; //字符串真实长度，不包括终止符
    uint8_t alloc;  //字符串最大容量，不包括终止符
    unsigned char flags; //head的类型
    char buf[]; //字符串主体
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags;
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; 
    uint32_t alloc;
    unsigned char flags; 
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; 
    uint64_t alloc;
    unsigned char flags;
    char buf[];
};
```



### 2.SDS的优点

1. **获取字符串长度O(1)** , 数据结构中len中存储了SDS 保存字符串的长度.
2. **防止缓冲区溢出**, C 字符串不记录自身的长度 ,所以字符串复制的时候,可能会产生缓冲区溢出.
3. **优化动态字符串的内存分配** 
   - 空间预分配: 对SDS修改时,会分配len长度(最大1M)的空间,当SDS连续增长时,空间分配次数会减少.
   - 惰性空间释放: SDS进行缩短操作时,不会重新分配内存,而是使用free属性存储未使用的字节数
4. **二进制安全**,如果保存二进制数据,遇到 '\0' ,会认为字符结束,导致数据丢失.SDS可以根据len来判断是否结束.





### 3.SDS的创建

**init属性:** 用于创建SDS,还是扩容SDS

**sdsReqType:**  根据长度 获取初始 type,type为SDS_TYPE_5/8/16/32/64,用于适配不同的长度

**sdsHdrSize:** 计算SDS的Header部分的长度.

**s_malloc:** 申请分配内存空间,申请的空间为header长度+主体长度 + 1(结束符 '\0')

```C
sds sdsnewlen(const void *init, size_t initlen) {
    void *sh;
    sds s;
    // 根据长度 获取初始 type
    char type = sdsReqType(initlen);
  	// 空的字符串通常被创建成 type 8，因为 type 5 已经不实用了
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    // 获取 header 长度
    int hdrlen = sdsHdrSize(type);
    
    unsigned char *fp;
	// 创建内存空间，空间大小等于 header长度+主体长度 + 1，后面加1是因为需要追加结束符，兼容 C 字符串
    sh = s_malloc(hdrlen+initlen+1);
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
         // 初始化
        memset(sh, 0, hdrlen+initlen+1);
     // 主体内容 指针地址，相当于整个 SDS 结构体向后偏移了整个 header 长度
    s = (char*)sh+hdrlen;
    // flags 指针为 主体 SDS 内容向前偏移1位（这个上面我们已经解释过了）
    fp = ((unsigned char*)s)-1;
    // 根据 type 值进行 header 各个字段的初始化
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
    }
    if (initlen && init)
        // 字符串拷贝
        memcpy(s, init, initlen);
    // 兼容 C 函数，在 字符串后添加结束符
    s[initlen] = '\0';
    return s;
}
```



