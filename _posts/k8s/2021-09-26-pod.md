---
layout: post
title: Pod介绍
category: k8s
tags: [k8s]
no-post-nav: true
---

## K8S-Pod

pod 是 Kubernetes 项目中最小的 API 对象。  是 Kubernetes 项目的原子调度单位 。



###  1.为什么我们会需要 Pod 

 <font color=#FF0000>容器的本质是进程</font> ，在操作系统中进程往往不会单独运行，而是以进程组的方式组织在一起。在操作系统的层面上，进程组更便于管理。将进程组的概念映射到容器技术中，便是Pod了。

若容器间存在紧密协作（互相间文件交换，使用localhost/socket文件本地通信，频繁的远程调用，需要共享linux的namespace），部署为同一个Pod会更加有利于调度。





###  2.Pod的实现原理 

1. **pod本身只是一个逻辑概念：**

    Kubernetes中真正处理的还是宿主机 操作系统上 Linux 容器的 Namespace 和 Cgroups 。Pod其本质就是一组共享了资源的容器。Pod里所有的容器，共享的同一个Network Namespace

2.  **Infra 容器 ：**

   在pod中,  Infra 容器 永远是第一个创建的，其实用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。  Infra 容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：`k8s.gcr.io/pause`。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。 

   通过infra容器，pod中的容器可以做到

   -  直接使用 localhost 进行通信 
   -  它们看到的网络设备跟 Infra 容器看到的完全一样 
   -  一个 Pod 只有一个 IP 地址，也就是这个 Pod 的 Network Namespace 对应的 IP 地址 
   -  其他的所有网络资源，都是一个 Pod 一份，并且被该 Pod 中的所有容器共享 
   -  Pod 的生命周期只跟 Infra 容器一致 
   -  Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的 



### 3. Pod如何操作Kubernetes API的

任意一个运行在 Kubernetes 集群里的 Pod ,会自动 声明一个类型是 Secret、名为 default-token-xxxx 的 Volume，然后 自动挂载在每个容器的一个固定目录上 

```
Volumes:
  default-token-9drx9:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-9drx9
    Optional:    false
```

 这个 Secret 类型的 Volume，正是默认 Service Account 对应的 ServiceAccountToken。 Kubernetes 其实在每个 Pod 创建的时候，自动在它的 spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段 .

所以pod创建完成后,可以从默认挂载目录 ( /var/run/secrets/kubernetes.io/serviceaccount )里访问到授权信息和文件 .



### 4.Pod的生命周期

​	Pod在生命周期中只会被调度一次,一旦被调度到某个节点,pod会一直在该节点上运行,直到销毁

1.  **Pending:**   Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间.
2.  **Running:**   Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。 
3.  **Succeeded:**  Pod 中的所有容器都已成功终止，并且不会再重启。 
4.  **Failed：**  Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。 
5.  **Unknown:**  因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败 



### 5.Pod的状态

1.  **PodScheduled:**  Pod 已经被调度到某节点 
2.  **ContainersReady:**  Pod 中所有容器都已就绪 
3.  **Initialized:**  所有的 Init 容器 都已成功启动 
4.  **Ready:**  Pod 可以为请求提供服务，并且应该被添加到对应服务的负载均衡池中 



### 6.Pod探针([Probe](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core))

​	Probe是由kubelet 对容器执行的定期诊断。 kubelet 调用由容器实现的 Handler。

- **ExecAction：** 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。 
- **TCPSocketAction：**  对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 
-  **HTTPGetAction：**  对容器的 IP 地址上指定端口和路径执行 HTTP Get 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。 



针对这几种Handler,容器可以选择执行哪些探针

-  **livenessProbe:**   指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其[重启策略](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)决定未来。如果容器不提供存活探针， 则默认状态为 `Success`。 
-  **readinessProbe:**  指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 `Failure`。 如果容器不提供就绪态探针，则默认状态为 `Success`。 
-  **startupProbe:**  指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，`kubelet` 将杀死容器，而容器依其 [重启策略](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)进行重启。 如果容器没有提供启动探测，则默认状态为 `Success`。 

